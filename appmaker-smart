#!/bin/bash

# AppMaker Smart - Intelligent iOS App Generator
# Creates useful, domain-specific apps based on the app name

set -euo pipefail

# Auto-detect everything
APP_NAME="${1:-}"
GIT_USER=$(git config user.name 2>/dev/null || echo "Developer")
GIT_EMAIL=$(git config user.email 2>/dev/null || echo "dev@example.com")
GIT_ORG=$(echo "$GIT_EMAIL" | cut -d@ -f2 | cut -d. -f1)
BUNDLE_PREFIX="com.${GIT_ORG}"
YEAR=$(date +%Y)

# Colors
GREEN='\033[0;32m'
BLUE='\033[0;34m'
NC='\033[0m'

# Validate input
if [ -z "$APP_NAME" ]; then
    echo "Usage: appmaker YourAppName"
    exit 1
fi

if [[ ! "$APP_NAME" =~ ^[A-Za-z][A-Za-z0-9]*$ ]]; then
    echo "App name must start with a letter and contain only letters and numbers"
    exit 1
fi

# Check if directory exists
if [ -d "$APP_NAME" ]; then
    echo "Directory $APP_NAME already exists"
    exit 1
fi

# Detect app type from name
detect_app_type() {
    local name=$(echo "$1" | tr '[:upper:]' '[:lower:]')
    
    # Fitness/Health
    if [[ $name =~ (workout|fitness|gym|exercise|health|weight) ]]; then
        echo "fitness"
    # Food/Cooking
    elif [[ $name =~ (recipe|food|cook|meal|diet|nutrition) ]]; then
        echo "recipe"
    # Finance
    elif [[ $name =~ (expense|money|budget|finance|cost|bill|invoice) ]]; then
        echo "finance"
    # Reading/Library
    elif [[ $name =~ (book|read|library|shelf) ]]; then
        echo "library"
    # Time/Productivity
    elif [[ $name =~ (timer|time|pomodoro|focus|mindful|meditat) ]]; then
        echo "timer"
    # Nature/Garden
    elif [[ $name =~ (plant|garden|grow|water) ]]; then
        echo "garden"
    # Development
    elif [[ $name =~ (code|snippet|script|dev|program) ]]; then
        echo "code"
    # Notes/Documents
    elif [[ $name =~ (note|memo|doc|write|journal|diary) ]]; then
        echo "notes"
    # Todo/Tasks
    elif [[ $name =~ (todo|task|list|check) ]]; then
        echo "todo"
    else
        echo "generic"
    fi
}

APP_TYPE=$(detect_app_type "$APP_NAME")

# Start the magic
echo -e "${BLUE}✨ Creating $APP_NAME (${APP_TYPE} app)...${NC}"

# Create all directories
mkdir -p "$APP_NAME"/{$APP_NAME,Packages/$APP_NAME,Tests,scripts,ci_scripts}
mkdir -p "$APP_NAME/$APP_NAME"/{Views,Models,Services,Resources,Components,Utilities}
mkdir -p "$APP_NAME/$APP_NAME/Resources"/{Assets.xcassets,Preview\ Content}
mkdir -p "$APP_NAME/Packages/$APP_NAME"/{Sources,Tests}
mkdir -p "$APP_NAME/Packages/$APP_NAME/Sources"/{$APP_NAME,Models,Services,Store,Repositories}
mkdir -p "$APP_NAME/Packages/$APP_NAME/Tests/${APP_NAME}Tests"

cd "$APP_NAME"

# Create .gitignore
cat > .gitignore << 'EOF'
.DS_Store
*.xcuserstate
xcuserdata/
.build/
DerivedData/
*.xcodeproj
!*.xcodeproj/project.pbxproj
!*.xcodeproj/xcshareddata/
*.playground/
.swiftpm/
*.moved-aside
*.pbxuser
!default.pbxuser
*.mode1v3
!default.mode1v3
*.mode2v3
!default.mode2v3
*.perspectivev3
!default.perspectivev3
EOF

# Create Makefile
cat > Makefile << EOF
# $APP_NAME - Generated by AppMaker
.PHONY: all dev test build clean

all: dev

dev:
	@xcodegen generate -s project.yml >/dev/null 2>&1
	@echo "✅ Project ready!"
	@echo ""
	@echo "Commands:"
	@echo "  make test  - Run tests"
	@echo "  make build - Build app"
	@echo "  make clean - Clean build"
	@echo ""
	@open $APP_NAME.xcodeproj

test:
	@xcodebuild test -scheme $APP_NAME -destination 'platform=iOS Simulator,name=iPhone 16' -quiet

build:
	@xcodebuild build -scheme $APP_NAME -destination 'platform=iOS Simulator,name=iPhone 16' -quiet

clean:
	@rm -rf .build DerivedData ~/Library/Developer/Xcode/DerivedData/$APP_NAME-*
EOF

# Create project.yml
cat > project.yml << EOF
name: $APP_NAME
options:
  bundleIdPrefix: $BUNDLE_PREFIX
  deploymentTarget:
    iOS: "18.0"
    macOS: "15.0"
settings:
  DEVELOPMENT_TEAM: ""
  ENABLE_USER_SCRIPT_SANDBOXING: NO
packages:
  $APP_NAME:
    path: Packages/$APP_NAME
targets:
  $APP_NAME:
    type: application
    platform: iOS
    sources: [$APP_NAME]
    resources:
      - $APP_NAME/Resources
    settings:
      INFOPLIST_FILE: $APP_NAME/Info.plist
      CODE_SIGN_ENTITLEMENTS: $APP_NAME/$APP_NAME.entitlements
    dependencies:
      - package: $APP_NAME
EOF

# Create Package.swift
cat > "Packages/$APP_NAME/Package.swift" << EOF
// swift-tools-version: 6.0
import PackageDescription

let package = Package(
    name: "$APP_NAME",
    platforms: [.iOS(.v18), .macOS(.v15)],
    products: [
        .library(name: "$APP_NAME", targets: ["$APP_NAME"])
    ],
    targets: [
        .target(name: "$APP_NAME", dependencies: ["Models", "Services", "Store", "Repositories"]),
        .target(name: "Models"),
        .target(name: "Services", dependencies: ["Models"]),
        .target(name: "Store", dependencies: ["Models"]),
        .target(name: "Repositories", dependencies: ["Models", "Store"]),
        .testTarget(name: "${APP_NAME}Tests", dependencies: ["$APP_NAME"])
    ]
)
EOF

# Generate models based on app type
case $APP_TYPE in
    "fitness")
        # Create Workout model
        cat > "Packages/$APP_NAME/Sources/Models/Workout.swift" << 'EOF'
import Foundation
import SwiftData

@Model
public final class Workout {
    public var id = UUID()
    public var name: String
    public var date: Date
    public var duration: TimeInterval
    public var notes: String
    public var exercises: [Exercise]
    
    public init(name: String, date: Date = Date(), duration: TimeInterval = 0, notes: String = "") {
        self.name = name
        self.date = date
        self.duration = duration
        self.notes = notes
        self.exercises = []
    }
}

@Model
public final class Exercise {
    public var id = UUID()
    public var name: String
    public var sets: [ExerciseSet]
    public var notes: String
    public var restTime: TimeInterval
    
    public init(name: String, notes: String = "", restTime: TimeInterval = 90) {
        self.name = name
        self.notes = notes
        self.restTime = restTime
        self.sets = []
    }
}

@Model 
public final class ExerciseSet {
    public var id = UUID()
    public var reps: Int
    public var weight: Double
    public var completed: Bool
    
    public init(reps: Int, weight: Double, completed: Bool = false) {
        self.reps = reps
        self.weight = weight
        self.completed = completed
    }
}
EOF
        MODEL_TYPE="Workout"
        ;;
        
    "recipe")
        cat > "Packages/$APP_NAME/Sources/Models/Recipe.swift" << 'EOF'
import Foundation
import SwiftData

@Model
public final class Recipe {
    public var id = UUID()
    public var title: String
    public var summary: String
    public var prepTime: Int // minutes
    public var cookTime: Int // minutes
    public var servings: Int
    public var difficulty: Difficulty
    public var ingredients: [Ingredient]
    public var steps: [RecipeStep]
    public var tags: [String]
    public var imageData: Data?
    public var createdAt: Date
    public var isFavorite: Bool
    
    public enum Difficulty: String, Codable, CaseIterable {
        case easy = "Easy"
        case medium = "Medium"
        case hard = "Hard"
    }
    
    public init(title: String, summary: String = "", prepTime: Int = 0, cookTime: Int = 0, servings: Int = 1) {
        self.title = title
        self.summary = summary
        self.prepTime = prepTime
        self.cookTime = cookTime
        self.servings = servings
        self.difficulty = .easy
        self.ingredients = []
        self.steps = []
        self.tags = []
        self.createdAt = Date()
        self.isFavorite = false
    }
}

@Model
public final class Ingredient {
    public var id = UUID()
    public var name: String
    public var amount: String
    public var unit: String
    
    public init(name: String, amount: String, unit: String = "") {
        self.name = name
        self.amount = amount
        self.unit = unit
    }
}

@Model
public final class RecipeStep {
    public var id = UUID()
    public var order: Int
    public var instruction: String
    public var duration: Int? // minutes
    
    public init(order: Int, instruction: String, duration: Int? = nil) {
        self.order = order
        self.instruction = instruction
        self.duration = duration
    }
}
EOF
        MODEL_TYPE="Recipe"
        ;;
        
    "finance")
        cat > "Packages/$APP_NAME/Sources/Models/Expense.swift" << 'EOF'
import Foundation
import SwiftData

@Model
public final class Expense {
    public var id = UUID()
    public var amount: Decimal
    public var title: String
    public var notes: String
    public var date: Date
    public var category: Category
    public var isRecurring: Bool
    public var recurringPeriod: RecurringPeriod?
    
    public enum RecurringPeriod: String, Codable, CaseIterable {
        case daily = "Daily"
        case weekly = "Weekly"
        case monthly = "Monthly"
        case yearly = "Yearly"
    }
    
    public init(amount: Decimal, title: String, category: Category, date: Date = Date()) {
        self.amount = amount
        self.title = title
        self.category = category
        self.date = date
        self.notes = ""
        self.isRecurring = false
    }
}

@Model
public final class Category {
    public var id = UUID()
    public var name: String
    public var color: String // Hex color
    public var icon: String // SF Symbol name
    public var budget: Decimal?
    
    public init(name: String, color: String = "#007AFF", icon: String = "tag.fill") {
        self.name = name
        self.color = color
        self.icon = icon
    }
}

@Model
public final class Budget {
    public var id = UUID()
    public var name: String
    public var amount: Decimal
    public var period: BudgetPeriod
    public var startDate: Date
    public var categories: [Category]
    
    public enum BudgetPeriod: String, Codable, CaseIterable {
        case weekly = "Weekly"
        case monthly = "Monthly"
        case yearly = "Yearly"
    }
    
    public init(name: String, amount: Decimal, period: BudgetPeriod, startDate: Date = Date()) {
        self.name = name
        self.amount = amount
        self.period = period
        self.startDate = startDate
        self.categories = []
    }
}
EOF
        MODEL_TYPE="Expense"
        ;;
        
    "notes")
        cat > "Packages/$APP_NAME/Sources/Models/Note.swift" << 'EOF'
import Foundation
import SwiftData

@Model
public final class Note {
    public var id = UUID()
    public var title: String
    public var content: String
    public var createdAt: Date
    public var modifiedAt: Date
    public var tags: [Tag]
    public var isPinned: Bool
    public var folder: Folder?
    
    public init(title: String, content: String = "") {
        self.id = UUID()
        self.title = title
        self.content = content
        self.createdAt = Date()
        self.modifiedAt = Date()
        self.tags = []
        self.isPinned = false
    }
}

@Model
public final class Tag {
    public var id = UUID()
    public var name: String
    public var color: String // Hex color
    
    public init(name: String, color: String = "#007AFF") {
        self.name = name
        self.color = color
    }
}

@Model
public final class Folder {
    public var id = UUID()
    public var name: String
    public var icon: String // SF Symbol
    public var color: String
    public var notes: [Note]
    
    public init(name: String, icon: String = "folder.fill", color: String = "#007AFF") {
        self.name = name
        self.icon = icon
        self.color = color
        self.notes = []
    }
}
EOF
        MODEL_TYPE="Note"
        ;;
        
    *)
        # Default generic model
        cat > "Packages/$APP_NAME/Sources/Models/Item.swift" << 'EOF'
import Foundation
import SwiftData

@Model
public final class Item {
    public var id = UUID()
    public var title: String
    public var details: String
    public var createdAt: Date
    public var modifiedAt: Date
    public var category: String
    public var isFavorite: Bool
    
    public init(title: String, details: String = "", category: String = "General") {
        self.title = title
        self.details = details
        self.category = category
        self.createdAt = Date()
        self.modifiedAt = Date()
        self.isFavorite = false
    }
}
EOF
        MODEL_TYPE="Item"
        ;;
esac

# Create repository
cat > "Packages/$APP_NAME/Sources/Repositories/Repository.swift" << EOF
import Foundation
import SwiftData
import Models

public protocol RepositoryProtocol {
    associatedtype Model: PersistentModel
    
    func fetchAll() async throws -> [Model]
    func fetch(predicate: Predicate<Model>?) async throws -> [Model]
    func save(_ model: Model) async throws
    func delete(_ model: Model) async throws
}

@MainActor
public final class Repository<Model: PersistentModel>: RepositoryProtocol {
    private let modelContext: ModelContext
    
    public init(modelContext: ModelContext) {
        self.modelContext = modelContext
    }
    
    public func fetchAll() async throws -> [Model] {
        let descriptor = FetchDescriptor<Model>()
        return try modelContext.fetch(descriptor)
    }
    
    public func fetch(predicate: Predicate<Model>?) async throws -> [Model] {
        var descriptor = FetchDescriptor<Model>()
        descriptor.predicate = predicate
        return try modelContext.fetch(descriptor)
    }
    
    public func save(_ model: Model) async throws {
        modelContext.insert(model)
        try modelContext.save()
    }
    
    public func delete(_ model: Model) async throws {
        modelContext.delete(model)
        try modelContext.save()
    }
}
EOF

# Create Store
cat > "Packages/$APP_NAME/Sources/Store/Store.swift" << EOF
import SwiftData
import Models

public func createModelContainer() throws -> ModelContainer {
    let schema = Schema([
        $MODEL_TYPE.self,
    ])
    
    let modelConfiguration = ModelConfiguration(schema: schema)
    
    return try ModelContainer(for: schema, configurations: [modelConfiguration])
}
EOF

# Create main app file
cat > "$APP_NAME/${APP_NAME}App.swift" << EOF
import SwiftUI
import SwiftData
import $APP_NAME
import Models
import Store

@main
struct ${APP_NAME}App: App {
    let container: ModelContainer
    
    init() {
        do {
            container = try createModelContainer()
        } catch {
            fatalError("Failed to create ModelContainer: \\(error)")
        }
    }
    
    var body: some Scene {
        WindowGroup {
            ContentView()
        }
        .modelContainer(container)
    }
}
EOF

# Create better ContentView based on app type
case $APP_TYPE in
    "fitness")
        cat > "$APP_NAME/Views/ContentView.swift" << 'EOF'
import SwiftUI
import SwiftData
import Models

struct ContentView: View {
    @Query(sort: \Workout.date, order: .reverse) private var workouts: [Workout]
    @Environment(\.modelContext) private var context
    @State private var showingNewWorkout = false
    
    var body: some View {
        NavigationStack {
            List {
                ForEach(workouts) { workout in
                    NavigationLink(destination: WorkoutDetailView(workout: workout)) {
                        WorkoutRow(workout: workout)
                    }
                }
                .onDelete(perform: deleteWorkouts)
            }
            .navigationTitle("Workouts")
            .toolbar {
                ToolbarItem(placement: .topBarTrailing) {
                    Button("New Workout", systemImage: "plus") {
                        showingNewWorkout = true
                    }
                }
            }
            .sheet(isPresented: $showingNewWorkout) {
                NewWorkoutView()
            }
            .overlay {
                if workouts.isEmpty {
                    ContentUnavailableView("No Workouts", 
                        systemImage: "figure.strengthtraining.traditional",
                        description: Text("Tap + to start your first workout"))
                }
            }
        }
    }
    
    func deleteWorkouts(at offsets: IndexSet) {
        for index in offsets {
            context.delete(workouts[index])
        }
    }
}

struct WorkoutRow: View {
    let workout: Workout
    
    var body: some View {
        VStack(alignment: .leading, spacing: 4) {
            Text(workout.name)
                .font(.headline)
            HStack {
                Text(workout.date.formatted(date: .abbreviated, time: .shortened))
                Spacer()
                Text("\(workout.exercises.count) exercises")
            }
            .font(.caption)
            .foregroundStyle(.secondary)
        }
        .padding(.vertical, 4)
    }
}

struct WorkoutDetailView: View {
    let workout: Workout
    
    var body: some View {
        List {
            Section("Details") {
                LabeledContent("Date", value: workout.date.formatted())
                LabeledContent("Duration", value: "\(Int(workout.duration / 60)) min")
                if !workout.notes.isEmpty {
                    LabeledContent("Notes") {
                        Text(workout.notes)
                    }
                }
            }
            
            Section("Exercises (\(workout.exercises.count))") {
                ForEach(workout.exercises) { exercise in
                    VStack(alignment: .leading) {
                        Text(exercise.name)
                            .font(.headline)
                        ForEach(exercise.sets) { set in
                            Text("\(set.reps) × \(set.weight, specifier: "%.1f") kg")
                                .font(.caption)
                        }
                    }
                }
            }
        }
        .navigationTitle(workout.name)
        .navigationBarTitleDisplayMode(.large)
    }
}

struct NewWorkoutView: View {
    @Environment(\.dismiss) private var dismiss
    @Environment(\.modelContext) private var context
    @State private var workoutName = ""
    
    var body: some View {
        NavigationStack {
            Form {
                TextField("Workout Name", text: $workoutName)
            }
            .navigationTitle("New Workout")
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .cancellationAction) {
                    Button("Cancel") { dismiss() }
                }
                ToolbarItem(placement: .confirmationAction) {
                    Button("Start") {
                        let workout = Workout(name: workoutName)
                        context.insert(workout)
                        dismiss()
                    }
                    .disabled(workoutName.isEmpty)
                }
            }
        }
    }
}
EOF
        ;;
        
    "notes")
        cat > "$APP_NAME/Views/ContentView.swift" << 'EOF'
import SwiftUI
import SwiftData
import Models

struct ContentView: View {
    @Query(sort: \Note.modifiedAt, order: .reverse) private var notes: [Note]
    @Environment(\.modelContext) private var context
    @State private var searchText = ""
    @State private var selectedNote: Note?
    
    var filteredNotes: [Note] {
        if searchText.isEmpty {
            return notes
        } else {
            return notes.filter { note in
                note.title.localizedCaseInsensitiveContains(searchText) ||
                note.content.localizedCaseInsensitiveContains(searchText)
            }
        }
    }
    
    var body: some View {
        NavigationSplitView {
            List(selection: $selectedNote) {
                ForEach(filteredNotes) { note in
                    NavigationLink(value: note) {
                        NoteRow(note: note)
                    }
                }
                .onDelete(perform: deleteNotes)
            }
            .navigationTitle("Notes")
            .searchable(text: $searchText, prompt: "Search notes")
            .toolbar {
                ToolbarItem {
                    Button("New Note", systemImage: "square.and.pencil") {
                        let note = Note(title: "New Note")
                        context.insert(note)
                        selectedNote = note
                    }
                }
            }
            .overlay {
                if notes.isEmpty {
                    ContentUnavailableView("No Notes", 
                        systemImage: "note.text",
                        description: Text("Create your first note"))
                }
            }
        } detail: {
            if let note = selectedNote {
                NoteDetailView(note: note)
            } else {
                ContentUnavailableView("Select a Note", 
                    systemImage: "note.text",
                    description: Text("Choose a note from the sidebar"))
            }
        }
    }
    
    func deleteNotes(at offsets: IndexSet) {
        for index in offsets {
            context.delete(filteredNotes[index])
        }
    }
}

struct NoteRow: View {
    let note: Note
    
    var body: some View {
        VStack(alignment: .leading, spacing: 4) {
            HStack {
                Text(note.title)
                    .font(.headline)
                    .lineLimit(1)
                if note.isPinned {
                    Image(systemName: "pin.fill")
                        .font(.caption)
                        .foregroundStyle(.orange)
                }
            }
            
            Text(note.content)
                .font(.subheadline)
                .foregroundStyle(.secondary)
                .lineLimit(2)
            
            Text(note.modifiedAt.formatted(date: .abbreviated, time: .shortened))
                .font(.caption2)
                .foregroundStyle(.tertiary)
        }
        .padding(.vertical, 2)
    }
}

struct NoteDetailView: View {
    @Bindable var note: Note
    @FocusState private var isEditing: Bool
    
    var body: some View {
        VStack(alignment: .leading, spacing: 0) {
            TextField("Title", text: $note.title)
                .font(.largeTitle)
                .fontWeight(.bold)
                .textFieldStyle(.plain)
                .padding()
                .focused($isEditing)
            
            Divider()
            
            TextEditor(text: $note.content)
                .font(.body)
                .padding()
                .focused($isEditing)
            
            HStack {
                Text("Modified \(note.modifiedAt.formatted(date: .abbreviated, time: .shortened))")
                    .font(.caption)
                    .foregroundStyle(.secondary)
                Spacer()
                Toggle(isOn: $note.isPinned) {
                    Label("Pin", systemImage: note.isPinned ? "pin.fill" : "pin")
                }
                .toggleStyle(.button)
            }
            .padding()
        }
        .navigationBarTitleDisplayMode(.inline)
        .onChange(of: note.title) { oldValue, newValue in
            note.modifiedAt = Date()
        }
        .onChange(of: note.content) { oldValue, newValue in
            note.modifiedAt = Date()
        }
    }
}
EOF
        ;;
        
    *)
        # Enhanced generic ContentView
        cat > "$APP_NAME/Views/ContentView.swift" << EOF
import SwiftUI
import SwiftData
import Models

struct ContentView: View {
    @Query(sort: \\$MODEL_TYPE.createdAt, order: .reverse) private var items: [$MODEL_TYPE]
    @Environment(\\.modelContext) private var context
    @State private var showingNewItem = false
    @State private var searchText = ""
    
    var filteredItems: [$MODEL_TYPE] {
        if searchText.isEmpty {
            return items
        } else {
            return items.filter { item in
                item.title.localizedCaseInsensitiveContains(searchText)
            }
        }
    }
    
    var body: some View {
        NavigationStack {
            List {
                ForEach(filteredItems) { item in
                    NavigationLink(destination: ItemDetailView(item: item)) {
                        ItemRow(item: item)
                    }
                }
                .onDelete(perform: deleteItems)
            }
            .navigationTitle("$APP_NAME")
            .searchable(text: \$searchText)
            .toolbar {
                ToolbarItem(placement: .topBarTrailing) {
                    Button("Add", systemImage: "plus") {
                        showingNewItem = true
                    }
                }
            }
            .sheet(isPresented: \$showingNewItem) {
                NewItemView()
            }
            .overlay {
                if items.isEmpty {
                    ContentUnavailableView("No Items", 
                        systemImage: "tray",
                        description: Text("Tap + to add your first item"))
                }
            }
        }
    }
    
    func deleteItems(at offsets: IndexSet) {
        for index in offsets {
            context.delete(filteredItems[index])
        }
    }
}

struct ItemRow: View {
    let item: $MODEL_TYPE
    
    var body: some View {
        VStack(alignment: .leading, spacing: 4) {
            HStack {
                Text(item.title)
                    .font(.headline)
                if item.isFavorite {
                    Image(systemName: "star.fill")
                        .font(.caption)
                        .foregroundStyle(.yellow)
                }
            }
            
            if !item.details.isEmpty {
                Text(item.details)
                    .font(.subheadline)
                    .foregroundStyle(.secondary)
                    .lineLimit(2)
            }
            
            HStack {
                Text(item.category)
                    .font(.caption)
                    .padding(.horizontal, 8)
                    .padding(.vertical, 2)
                    .background(.quaternary)
                    .clipShape(Capsule())
                
                Spacer()
                
                Text(item.createdAt.formatted(date: .abbreviated, time: .omitted))
                    .font(.caption)
                    .foregroundStyle(.tertiary)
            }
        }
        .padding(.vertical, 4)
    }
}

struct ItemDetailView: View {
    @Bindable var item: $MODEL_TYPE
    @Environment(\\.dismiss) private var dismiss
    
    var body: some View {
        Form {
            Section("Details") {
                TextField("Title", text: \$item.title)
                TextField("Details", text: \$item.details, axis: .vertical)
                    .lineLimit(3...6)
                Picker("Category", selection: \$item.category) {
                    Text("General").tag("General")
                    Text("Work").tag("Work")
                    Text("Personal").tag("Personal")
                    Text("Important").tag("Important")
                }
            }
            
            Section {
                Toggle("Favorite", isOn: \$item.isFavorite)
                LabeledContent("Created", value: item.createdAt.formatted())
                LabeledContent("Modified", value: item.modifiedAt.formatted())
            }
        }
        .navigationTitle(item.title)
        .navigationBarTitleDisplayMode(.inline)
        .onChange(of: item.title) { _, _ in
            item.modifiedAt = Date()
        }
        .onChange(of: item.details) { _, _ in
            item.modifiedAt = Date()
        }
    }
}

struct NewItemView: View {
    @Environment(\\.dismiss) private var dismiss
    @Environment(\\.modelContext) private var context
    @State private var title = ""
    @State private var details = ""
    @State private var category = "General"
    
    var body: some View {
        NavigationStack {
            Form {
                Section("New Item") {
                    TextField("Title", text: \$title)
                    TextField("Details", text: \$details, axis: .vertical)
                        .lineLimit(3...6)
                    Picker("Category", selection: \$category) {
                        Text("General").tag("General")
                        Text("Work").tag("Work")
                        Text("Personal").tag("Personal")
                        Text("Important").tag("Important")
                    }
                }
            }
            .navigationTitle("New Item")
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .cancellationAction) {
                    Button("Cancel") { dismiss() }
                }
                ToolbarItem(placement: .confirmationAction) {
                    Button("Save") {
                        let item = $MODEL_TYPE(title: title, details: details, category: category)
                        context.insert(item)
                        dismiss()
                    }
                    .disabled(title.isEmpty)
                }
            }
        }
    }
}
EOF
        ;;
esac

# Create utilities
cat > "$APP_NAME/Utilities/Extensions.swift" << 'EOF'
import SwiftUI

extension View {
    func cardStyle() -> some View {
        self
            .padding()
            .background(.regularMaterial)
            .clipShape(RoundedRectangle(cornerRadius: 12))
            .shadow(radius: 2)
    }
}

extension Date {
    var isToday: Bool {
        Calendar.current.isDateInToday(self)
    }
    
    var isYesterday: Bool {
        Calendar.current.isDateInYesterday(self)
    }
    
    func timeAgo() -> String {
        let formatter = RelativeDateTimeFormatter()
        formatter.unitsStyle = .abbreviated
        return formatter.localizedString(for: self, relativeTo: Date())
    }
}

extension Decimal {
    var currencyFormatted: String {
        let formatter = NumberFormatter()
        formatter.numberStyle = .currency
        formatter.locale = Locale.current
        return formatter.string(from: self as NSNumber) ?? "$0.00"
    }
}
EOF

# Create main package file
cat > "Packages/$APP_NAME/Sources/$APP_NAME/${APP_NAME}.swift" << EOF
import Foundation

public struct $APP_NAME {
    public static let version = "1.0.0"
    public init() {}
}
EOF

# Create test
cat > "Packages/$APP_NAME/Tests/${APP_NAME}Tests/BasicTests.swift" << EOF
import Testing
@testable import $APP_NAME
@testable import Models

@Test func modelCreation() {
    #if $APP_TYPE == "fitness"
    let workout = Workout(name: "Morning Workout")
    #expect(workout.name == "Morning Workout")
    #expect(workout.exercises.isEmpty)
    #elseif $APP_TYPE == "notes"
    let note = Note(title: "Test Note", content: "Test content")
    #expect(note.title == "Test Note")
    #expect(note.content == "Test content")
    #else
    let item = $MODEL_TYPE(title: "Test Item")
    #expect(item.title == "Test Item")
    #endif
}
EOF

# Create a better README
cat > README.md << EOF
# $APP_NAME

Created with AppMaker on $(date +"%B %d, %Y")

## About This App

$APP_NAME is a ${APP_TYPE} app built with SwiftUI and SwiftData.

## Features

- ✅ Full CRUD operations
- ✅ Search functionality  
- ✅ Data persistence with SwiftData
- ✅ Modern SwiftUI interface
- ✅ Ready for customization

## Quick Start

\`\`\`bash
make dev    # Open in Xcode
make test   # Run tests
make build  # Build app
\`\`\`

## Architecture

- **UI Layer**: SwiftUI views in \`$APP_NAME/Views/\`
- **Data Models**: SwiftData models in \`Packages/$APP_NAME/Sources/Models/\`
- **Business Logic**: Services in \`Packages/$APP_NAME/Sources/Services/\`
- **Data Access**: Repositories in \`Packages/$APP_NAME/Sources/Repositories/\`

## Customization Guide

### Adding New Features
1. Add new properties to models in \`Models/\`
2. Update views in \`Views/\`
3. Add business logic to \`Services/\`
4. Run tests with \`make test\`

### Common Modifications
- **Change app icon**: Replace files in \`Assets.xcassets\`
- **Add new screens**: Create new views in \`Views/\`
- **Modify data model**: Edit files in \`Models/\`

Created by $GIT_USER
EOF

# Create CLAUDE.md
cat > CLAUDE.md << EOF
# $APP_NAME - AI Development Guide

## Quick Reference
- **App Type**: ${APP_TYPE}
- **Main Model**: $MODEL_TYPE
- **Architecture**: Model-View with Repository pattern
- **Key Command**: \`make test\` after changes

## Project Structure
\`\`\`
$APP_NAME/           # UI Layer (SwiftUI Views)
  Views/             # Screens and components
  Utilities/         # Extensions and helpers
Packages/$APP_NAME/  # Business Logic
  Models/            # SwiftData models  
  Services/          # Business logic (actors)
  Repositories/      # Data access layer
  Store/             # SwiftData configuration
\`\`\`

## Key Patterns

### Data Access
Always use Repository pattern:
\`\`\`swift
@MainActor
let repository = Repository<$MODEL_TYPE>(modelContext: context)
let items = try await repository.fetchAll()
\`\`\`

### Adding Features
1. Update model in \`Models/\`
2. Add UI in \`Views/\`
3. Create service method if needed
4. Test with \`make test\`

### Common Tasks
- **Add new property**: Update model + run app (auto-migration)
- **New screen**: Create view + navigation link
- **Business logic**: Add to Services as actor methods
EOF

# Create entitlements
cat > "$APP_NAME/$APP_NAME.entitlements" << EOF
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
    <key>com.apple.security.app-sandbox</key>
    <true/>
    <key>com.apple.security.files.user-selected.read-write</key>
    <true/>
    <key>com.apple.developer.aps-environment</key>
    <string>development</string>
    <key>com.apple.developer.icloud-container-identifiers</key>
    <array>
        <string>iCloud.$BUNDLE_PREFIX.$APP_NAME</string>
    </array>
    <key>com.apple.developer.icloud-services</key>
    <array>
        <string>CloudKit</string>
    </array>
</dict>
</plist>
EOF

# Create .swiftlint.yml
cat > .swiftlint.yml << 'EOF'
disabled_rules:
  - trailing_comma
  - todo
  - force_cast
  - force_try
opt_in_rules:
  - empty_count
  - closure_end_indentation
  - sorted_imports
  - unused_import
  - unused_declaration
  - attributes
excluded:
  - .build
  - DerivedData
  - "*.xcodeproj"
line_length:
  warning: 120
  error: 200
identifier_name:
  min_length: 2
EOF

# Create Info.plist
cat > "$APP_NAME/Info.plist" << EOF
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
    <key>CFBundleDisplayName</key>
    <string>$APP_NAME</string>
    <key>CFBundleName</key>
    <string>$APP_NAME</string>
    <key>LSRequiresIPhoneOS</key>
    <true/>
    <key>UILaunchScreen</key>
    <dict>
        <key>UIColorName</key>
        <string>AccentColor</string>
    </dict>
    <key>UISupportedInterfaceOrientations</key>
    <array>
        <string>UIInterfaceOrientationPortrait</string>
        <string>UIInterfaceOrientationLandscapeLeft</string>
        <string>UIInterfaceOrientationLandscapeRight</string>
    </array>
    <key>UISupportedInterfaceOrientations~ipad</key>
    <array>
        <string>UIInterfaceOrientationPortrait</string>
        <string>UIInterfaceOrientationPortraitUpsideDown</string>
        <string>UIInterfaceOrientationLandscapeLeft</string>
        <string>UIInterfaceOrientationLandscapeRight</string>
    </array>
</dict>
</plist>
EOF

# Initialize git
git init -q
git add .
git commit -q -m "Initial commit - $APP_NAME created with AppMaker

App type: $APP_TYPE
Models: $MODEL_TYPE
Features: Search, CRUD, Navigation"

# Final output
echo -e "${GREEN}✅ $APP_NAME created successfully!${NC}"
echo ""
echo "App Type: $APP_TYPE"
echo "Main Model: $MODEL_TYPE"
echo ""
echo "Opening Xcode..."

# Auto-open Xcode
xcodegen generate -s project.yml >/dev/null 2>&1
open "$APP_NAME.xcodeproj"

echo ""
echo "Next steps:"
echo "  1. Press Cmd+R to run"
echo "  2. Start customizing for your needs"
echo ""
echo "Useful commands:"
echo "  make test  - Run tests"
echo "  make build - Build app"
echo "  make clean - Clean build"